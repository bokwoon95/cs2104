-- Problem 1 (*) Find the last element of a list.
-- (Note that the Lisp transcription of this problem is incorrect.)
-- Example in Haskell:
-- λ> myLast [1,2,3,4]
-- 4
-- λ> myLast ['x','y','z']
-- 'z'

-- Problem 2
-- (*) Find the last but one element of a list.
-- (Note that the Lisp transcription of this problem is incorrect.)
-- Example in Haskell:
-- λ> myButLast [1,2,3,4]
-- 3
-- λ> myButLast ['a'..'z']
-- 'y'

-- Problem 3
-- (*) Find the K'th element of a list. The first element in the list is number 1.
-- Example:
-- (element-at '(a b c d e) 3)
-- c
-- Example in Haskell:
-- λ> elementAt [1,2,3] 2
-- 2
-- λ> elementAt "haskell" 5
-- 'e'

-- Problem 4
-- (*) Find the number of elements of a list.
-- Example in Haskell:
-- λ> myLength [123, 456, 789]
-- 3
-- λ> myLength "Hello, world!"
-- 13

-- Problem 5
-- (*) Reverse a list.
-- Example in Haskell:
-- λ> myReverse "A man, a plan, a canal, panama!"
-- "!amanap ,lanac a ,nalp a ,nam A"
-- λ> myReverse [1,2,3,4]
-- [4,3,2,1]

-- Problem 6
-- (*) Find out whether a list is a palindrome. A palindrome can be read
-- forward or backward; e.g. (x a m a x).
-- Example in Haskell:
-- λ> isPalindrome [1,2,3]
-- False
-- λ> isPalindrome "madamimadam"
-- True
-- λ> isPalindrome [1,2,4,8,16,8,4,2,1]
-- True

-- Problem 7
-- (**) Flatten a nested list structure.
-- Transform a list, possibly holding lists as elements into a `flat' list by
-- replacing each list with its elements (recursively).
-- Example:
-- (my-flatten '(a (b (c d) e)))
-- (A B C D E)
-- Example in Haskell:
-- We have to define a new data type, because lists in Haskell are homogeneous.
 -- data NestedList a = Elem a | List [NestedList a]
-- λ> flatten (Elem 5)
-- [5]
-- λ> flatten (List [Elem 1, List [Elem 2, List [Elem 3, Elem 4], Elem 5]])
-- [1,2,3,4,5]
-- λ> flatten (List [])
-- []

-- Problem 8
-- (**) Eliminate consecutive duplicates of list elements.
-- If a list contains repeated elements they should be replaced with a single
-- copy of the element. The order of the elements should not be changed.
-- Example:
-- (compress '(a a a a b c c a a d e e e e))
-- (A B C A D E)
-- Example in Haskell:
-- λ> compress "aaaabccaadeeee"
-- "abcade"

-- Problem 9
-- (**) Pack consecutive duplicates of list elements into sublists. If a list
-- contains repeated elements they should be placed in separate sublists.
-- Example:
-- (pack '(a a a a b c c a a d e e e e))
-- ((A A A A) (B) (C C) (A A) (D) (E E E E))
-- Example in Haskell:
-- λ> pack ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a',
             -- 'a', 'd', 'e', 'e', 'e', 'e']
-- ["aaaa","b","cc","aa","d","eeee"]

-- Problem 10
-- (*) Run-length encoding of a list. Use the result of problem P09 to
-- implement the so-called run-length encoding data compression method.
-- Consecutive duplicates of elements are encoded as lists (N E) where N is the
-- number of duplicates of the element E.
-- Example:
-- (encode '(a a a a b c c a a d e e e e))
-- ((4 A) (1 B) (2 C) (2 A) (1 D)(4 E))
-- Example in Haskell:
-- λ> encode "aaaabccaadeeee"
-- [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]

-- Problem 11
-- (*) Modified run-length encoding.
-- Modify the result of problem 10 in such a way that if an element has no
-- duplicates it is simply copied into the result list. Only elements with
-- duplicates are transferred as (N E) lists.
-- Example:
-- (encode-modified '(a a a a b c c a a d e e e e))
-- ((4 A) B (2 C) (2 A) D (4 E))
-- Example in Haskell:
-- λ> encodeModified "aaaabccaadeeee"
-- [Multiple 4 'a',Single 'b',Multiple 2 'c',
 -- Multiple 2 'a',Single 'd',Multiple 4 'e']

-- Problem 12
-- (**) Decode a run-length encoded list.
-- Given a run-length code list generated as specified in problem 11. Construct its uncompressed version.
-- Example in Haskell:
-- λ> decodeModified 
       -- [Multiple 4 'a',Single 'b',Multiple 2 'c',
        -- Multiple 2 'a',Single 'd',Multiple 4 'e']
-- "aaaabccaadeeee"

-- Problem 13
-- (**) Run-length encoding of a list (direct solution).
-- Implement the so-called run-length encoding data compression method
-- directly. I.e. don't explicitly create the sublists containing the
-- duplicates, as in problem 9, but only count them. As in problem P11,
-- simplify the result list by replacing the singleton lists (1 X) by X.
-- Example:
-- (encode-direct '(a a a a b c c a a d e e e e))
-- ((4 A) B (2 C) (2 A) D (4 E))
-- Example in Haskell:
-- λ> encodeDirect "aaaabccaadeeee"
-- [Multiple 4 'a',Single 'b',Multiple 2 'c',
-- Multiple 2 'a',Single 'd',Multiple 4 'e']

-- Problem 14
-- (*) Duplicate the elements of a list.
-- Example:
-- (dupli '(a b c c d))
-- (A A B B C C C C D D)
-- Example in Haskell:
-- λ> dupli [1, 2, 3]
-- [1,1,2,2,3,3]

-- Problem 15
-- (**) Replicate the elements of a list a given number of times.
-- Example:
-- (repli '(a b c) 3)
-- (A A A B B B C C C)
-- Example in Haskell:
-- λ> repli "abc" 3
-- "aaabbbccc"

-- Problem 16
-- (**) Drop every N'th element from a list.
-- Example:
-- (drop '(a b c d e f g h i k) 3)
-- (A B D E G H K)
-- Example in Haskell:
-- λ> dropEvery "abcdefghik" 3
-- "abdeghk"

-- Problem 17
-- (*) Split a list into two parts; the length of the first part is given.
-- Do not use any predefined predicates.
-- Example:
-- (split '(a b c d e f g h i k) 3)
-- ( (A B C) (D E F G H I K))
-- Example in Haskell:
-- λ> split "abcdefghik" 3
-- ("abc", "defghik")

-- Problem 18
-- (**) Extract a slice from a list.
-- Given two indices, i and k, the slice is the list containing the elements
-- between the i'th and k'th element of the original list (both limits
-- included). Start counting the elements with 1.
-- Example:
-- (slice '(a b c d e f g h i k) 3 7)
-- (C D E F G)
-- Example in Haskell:
-- λ> slice ['a','b','c','d','e','f','g','h','i','k'] 3 7
-- "cdefg"

-- Problem 19
-- (**) Rotate a list N places to the left.
-- Hint: Use the predefined functions length and (++).
-- Examples:
-- (rotate '(a b c d e f g h) 3)
-- (D E F G H A B C)
-- (rotate '(a b c d e f g h) -2)
-- (G H A B C D E F)
-- Examples in Haskell:
-- λ> rotate ['a','b','c','d','e','f','g','h'] 3
-- "defghabc"
-- λ> rotate ['a','b','c','d','e','f','g','h'] (-2)
-- "ghabcdef"

-- Problem 20
-- (*) Remove the K'th element from a list.
-- Example in Prolog:
-- ?- remove_at(X,[a,b,c,d],2,R).
-- X = b
-- R = [a,c,d]
-- Example in Lisp:
-- (remove-at '(a b c d) 2)
-- (A C D)
-- (Note that this only returns the residue list, while the Prolog version also returns the deleted element.)
-- Example in Haskell:
-- λ> removeAt 2 "abcd"
-- ('b',"acd")

-- Problem 21
-- Insert an element at a given position into a list.
-- Example:
-- (insert-at 'alfa '(a b c d) 2)
-- (A ALFA B C D)
-- Example in Haskell:
-- λ> insertAt 'X' "abcd" 2
-- "aXbcd"

-- Problem 22
-- Create a list containing all integers within a given range.
-- Example:
-- (range 4 9)
-- (4 5 6 7 8 9)
-- Example in Haskell:
-- λ> range 4 9
-- [4,5,6,7,8,9]

-- Problem 23
-- Extract a given number of randomly selected elements from a list.
-- Example:
-- (rnd-select '(a b c d e f g h) 3)
-- (E D A)
-- Example in Haskell:
-- λ> rnd_select "abcdefgh" 3 >>= putStrLn
-- eda

-- Problem 24
-- Lotto: Draw N different random numbers from the set 1..M.
-- Example:
-- (rnd-select 6 49)
-- (23 1 17 33 21 37)
-- Example in Haskell:
-- λ> diff_select 6 49
-- [23,1,17,33,21,37]

-- Problem 25
-- Generate a random permutation of the elements of a list.
-- Example:
-- (rnd-permu '(a b c d e f))
-- (B A D C E F)
-- Example in Haskell:
-- λ> rnd_permu "abcdef"
-- "badcef"

-- Problem 26
-- (**) Generate the combinations of K distinct objects chosen from the N elements of a list
-- In how many ways can a committee of 3 be chosen from a group of 12 people?
-- We all know that there are C(12,3) = 220 possibilities (C(N,K) denotes the
-- well-known binomial coefficients). For pure mathematicians, this result may
-- be great. But we want to really generate all the possibilities in a list.
-- Example:
-- (combinations 3 '(a b c d e f))
-- ((A B C) (A B D) (A B E) ... )
-- Example in Haskell:
-- λ> combinations 3 "abcdef"
-- ["abc","abd","abe",...]

-- Problem 27
-- Group the elements of a set into disjoint subsets.
-- a) In how many ways can a group of 9 people work in 3 disjoint subgroups of
-- 2, 3 and 4 persons? Write a function that generates all the possibilities
-- and returns them in a list.
-- Example:
-- (group3 '(aldo beat carla david evi flip gary hugo ida))
-- ( ( (ALDO BEAT) (CARLA DAVID EVI) (FLIP GARY HUGO IDA) )
-- ... )
-- b) Generalize the above predicate in a way that we can specify a list of
-- group sizes and the predicate will return a list of groups.
-- Example:
-- (group '(aldo beat carla david evi flip gary hugo ida) '(2 2 5))
-- ( ( (ALDO BEAT) (CARLA DAVID) (EVI FLIP GARY HUGO IDA) )
-- ... )
-- Note that we do not want permutations of the group members; i.e. ((ALDO
-- BEAT) ...) is the same solution as ((BEAT ALDO) ...). However, we make a
-- difference between ((ALDO BEAT) (CARLA DAVID) ...) and ((CARLA DAVID) (ALDO
-- BEAT) ...).  You may find more about this combinatorial problem in a good
-- book on discrete mathematics under the term "multinomial coefficients".
-- Example in Haskell:
-- λ> group [2,3,4] ["aldo","beat","carla","david","evi","flip","gary","hugo","ida"]
-- [[["aldo","beat"],["carla","david","evi"],["flip","gary","hugo","ida"]],...]
-- (altogether 1260 solutions)
-- λ> group [2,2,5] ["aldo","beat","carla","david","evi","flip","gary","hugo","ida"]
-- [[["aldo","beat"],["carla","david"],["evi","flip","gary","hugo","ida"]],...]
-- (altogether 756 solutions)

-- Problem 28
-- Sorting a list of lists according to length of sublists
-- a) We suppose that a list contains elements that are lists themselves. The
-- objective is to sort the elements of this list according to their length.
-- E.g. short lists first, longer lists later, or vice versa.
-- Example:
-- (lsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
-- ((O) (D E) (D E) (M N) (A B C) (F G H) (I J K L))
-- Example in Haskell:
-- λ> lsort ["abc","de","fgh","de","ijkl","mn","o"]
-- ["o","de","de","mn","abc","fgh","ijkl"]
-- b) Again, we suppose that a list contains elements that are lists
-- themselves. But this time the objective is to sort the elements of this list
-- according to their length frequency; i.e., in the default, where sorting is
-- done ascendingly, lists with rare lengths are placed first, others with a
-- more frequent length come later.
-- Example:
-- (lfsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
-- ((i j k l) (o) (a b c) (f g h) (d e) (d e) (m n))
-- Example in Haskell:
-- λ> lfsort ["abc", "de", "fgh", "de", "ijkl", "mn", "o"]
-- ["ijkl","o","abc","fgh","de","de","mn"]
